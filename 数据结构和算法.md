# -1在java中表示的编码

符号位：**1为负数**，**0为正数**

为什么是11111111111111111111111111111111

因为计算机中是以**补码**形式存储的

所以

| 符号位 | 补码                            |
| ------ | ------------------------------- |
| 1      | 1111111111111111111111111111111 |

转换为反码

| 符号位 | 反码                            |
| ------ | ------------------------------- |
| 1      | 1111111111111111111111111111110 |

转换为原码

| 符号位 | 原码                            |
| ------ | ------------------------------- |
| 1      | 0000000000000000000000000000001 |

原码反码补码转换规律

**正数**的原、反、补是一样的

**负数**

原码-------->反码（符号位不变，其余位置全部取反）-----------补码（符号位不变，末位加1）

# &、|、^三者运算区别

底层都是转换为二进制然后在进行运算

**&：同真为真**

```
00000000000000000000000000001100
-----------
00000000000000000000000000001101
--------------
00000000000000000000000000001100
```

**|：全假为假**

```
00000000000000000000000000001100
-----------
00000000000000000000000000001101
--------------
00000000000000000000000000001101
```

**^：相同为假，不同为真**

```
00000000000000000000000000001100
-----------
00000000000000000000000000001101
--------------
00000000000000000000000000000001
```

# 右移运算>>和>>>的区别

符号>>代表**带符号位**右移

符号>>>代表**不带符号**位右移

```java
 int a = Integer.MIN_VALUE;
 a >> 1
 11000000000000000000000000000000
 a >>> 1
 01000000000000000000000000000000
```

# ~取反

任何数的相反数都是**~x+1**

```java
int a = 14;
00000000000000000000000000001110
11111111111111111111111111110001  ===> +1
11111111111111111111111111110010  ===> -14
```

正数的相反数都会有一个负数对应，因为正数会比负数少一个

但是负数的最小数的相反数是它本身

```java
//最小值
int a = Integer.MIN_VALUE;
10000000000000000000000000000000
01111111111111111111111111111111 ==>~
10000000000000000000000000000000 ==>+1
```

溢出部分删除不要

# 最基本的数据结构

## 数组

便于寻址，不便于增删数据

## 链表

便于增删数据，不便于寻址





