# 1.while()中的参数

while()中的表达式判断必须是boolean类型

# 2.list的add方法

list的add方法在添加时，如果有值，则会在当前位置添加值，其余数值往后移

```
list{5,3,1}
nums.add(6); //往后边加一个6，{5，3，1，6}
nums.add(0,4);//往下标为0的数加一个4，{4，5，3，1，6}
nums.remove(1); // 移除下标为1 的元素，{4，3，1，6}
```

# 3.post和get的区别和特性

1. Get是不安全的，因为在传输过程，数据被放在请求的URL中；Post的所有操作对用户来说都是不可见的。
2. Get传送的数据量较小，这主要是因为受URL长度限制；Post传送的数据量较大，一般被默认为不受限制。
3. Get限制Form表单的数据集的值必须为ASCII字符；而Post支持整个ISO10646字符集。
4. Get执行效率却比Post方法好。Get是form提交的默认方法。

# 4.数据库的事务四大特性

## 4.1 原子性（Atomicity）

原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。

## 4.2 一致性（Isolation）

是指事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。
保证数据库一致性是指当事务完成时，必须使所有数据都具有一致的状态。，例如在银行转账的时候，A账户上有金额300元，B账户上有200元，A给B转账100，AB账户上的金额总和依然是500元

## 4.3 隔离性（Consistency）

隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。

## 4.4 持久性（Durability）

持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的

# 5.重写与重载 

## 5.1 方法重载Overload

1、同一个类中

2、方法名相同，参数列表不同（参数顺序、个数、类型）

3、方法返回值、访问修饰符任意

4、与方法的参数名无关

## 5.2 方法重写Override

1、有继承关系的子类中

2、方法名相同，参数列表相同（参数顺序、个数、类型），方法返回值相同

3、访问修饰符，访问范围需要大于等于父类的访问范围

4、与方法的参数名无关

# 6.两个方法就方法返回值不一样，为什么会报错

方法名如果相同，那么就相当于要方法重载，方法重载的条件就是方法名相同，形参列表不同，但是上述问题，形参列表是相同的，所以说会报错。

# 7.数据库的事务隔离性

![事务四大特征](..\笔记\MySQLimg\事务四大特征.png)

# 8.java8新增的特性 

## 1.lambda表达式

需要Functionalinterface才能进行简化

```java
//接口
@Functionalinterface
public interface Test{
	void test();
}

//实现类
public class TestDemo{
	public static void main(String[] args){
		Test t = new Test({
			@override
			public void test(){
				System.out.println("这是一个测试");
			}
		})
	}
}


//lambda表达式简化
//实现类
public class TestDemo{
	public static void main(String[] args){
		Test t = () -> System.out.println("这是简化版本!!");
	}
}
```

## 2.StringJoiner

```java
//拼接字符串
StringJoiner sj = new StringJoiner(间隔符,开始符号,结束符号);

StringJoiner sj = new StringJoiner("--","[","]");
sj.add("1").add("1").add("1").add("1").add("1").add("1");
System.out.println(sj);
System.out.println(sj);//[1--1--1--1--1--1]
```

## 3.Interface 

![接口JDK1.8新增方法](E:\笔记\刷题经验img\接口JDK1.8新增方法.png)

```java
public class P7 implements A {
    public static void main(String[] args) {
        A test = new A() {
            @Override
            public void test() {
                System.out.println("dajkfhajk");
            }

            @Override
            public void go() {
                A.super.go();
            }
        };
        test.go();
        A.study();
    }

    @Override
    public void test() {
        System.out.println("sdfakfj");
    }
}


interface A{
    void test();

    default void go(){
        System.out.println("fuck you!!!");
    }
    static void study(){
        System.out.println("学你m!!!");
    }

}

```



## 4.日期API 

![JDK8新增日期时间对象](E:\笔记\刷题经验img\JDK8新增日期时间对象.png)

LocalDateTime	比较时间和日期 

LocalDate	比较日期

LocalTime	比较时间

都是接口

ChronoUnit 计算两个日期的时间

## 5.stream

流只能使用一次

常用的方法

```java
filter()//过滤
limit()//获取前几个元素
skip()//跳过几个元素
distinct()//去重
concat()//合并流
```

常见的终结方法

```java
forEach()//对流的遍历
count()//返回元素数
```

收集Stream流

```java
toList()//收集List集合
toSet()//收集Set集合
toMap()//收集Map集合
```



# 9.stream的具体操作



# 10.左连接与内连接的区别

以左边的表为基准，不管左边的表有无数据都会显示左表数据。

# 11.jwt的三个部分



# 12.spring的ioc

## 分为三个方面容器、控制反转、依赖注入

### 容器

是一个配置文件
相当于一个map容器存放的各种对象、注解比如@Controller、@Service、@Mapper。
存放的原理是通过全限定类名使用反射原理将对象存放在map中

### 控制反转

原本对象A依赖于对象B
但是现在我把A对象和B对象交给容器管理，这样就大大降低对象之间的耦合

### 依赖注入

把容器中的两个bean对象关联起来
通过配置文件中的ref属性根据id注入将A容器注入到B容器中

# 13.SpringMVC的启动流程



# 14.闰年的判断条件

```java
y % 100 !== 0 && y/4 == 0 || y / 400 == 0
```

# 15.命令javac-d参数的用途是？

指定编译后类层次的根目录

# 16.list是一个ArrayList的对象，哪个选项的代码填到//todo delete处，可以在Iterator遍历的过程中正确并安全的删除一个list中保存的对象

```java
Iterator it = list.iterator();
int index = 0;
while (it.hasNext())
{
    Object obj = it.next();
    if (needDelete(obj))  //needDelete返回boolean，决定是否要删除
    {
        //todo delete
    }
    index ++;
}
```

```
it.remove();
```

# 17.Object中一共有多少方法

![object](E:\笔记\刷题经验img\object.png)

# 18.java用（）机制实现了线程之间的同执行

监视器

# 19.synchronized 为什么 不能锁 Integer

integer底层会有一个hash值，integer值每次改变，hash值都会改变

# 20.String拼接字符串的底层原理

```
//有变量参与情况 
//JDK8 以前会使用StringBuilder进行拼接
String s1 = "a";//会在串池中产生一个字符"a"
String s2 = s1 + "b";// new StringBuilder().apppend(s1).append("b").toString();
String s3 = s2 + "c";// new StringBuilder().apppend(s2).append("c").toString();
//JDK8 首先会在底层预估字符串拼接后的总大小，然后把拼接内容放在数组中，此时也是产生了一个新的字符串
//总结：不管是新的版本还是旧的版本，系统都会在底层创建一个新的StringBuilder对象

//无变量参与情况
String s = "a" + "b" + "c"; //java文件
如果拼接的时候没有变量，就会触发字符串的优化机制，在编译的时候就已经是最终结果了
====> String s = "abc"; //class文件
```

# 21.StringBuilder底层执行逻辑

```
new StringBuilder().append().....
```

他会往后面增加数据，而不是像String一样,所以他的拼接性能会比String好

# 22.String字符串面试题

```java
String s1 ="abc";

String s2 ="a" + "b" + "c";//他会复用串池里面管理的地址，然后把他们连接在一起，并不会重新new一个对象

System.out.println(s1 == s2); // true


String s1 ="abc"; //@dksjfal

String s2 ="ab"; //@lksdjaflak

String s3 = s2 + "c";//底层会new一个StringBuilder对象进行拼接字符串，所以地址中是不一样的	

System.out.println(s1 == s3); // false
```

总结：拼接的时候如果**没有变量参与**，他就会将现有的字符进行拼接，会重复使用串池中的字符串。

**有变量参与时**，他会创建一个StringBuilder对象对字符进行拼接，会浪费内存。

# 23.StringBuilder源码分析

默认容量: 16

添加字符时，存储的时字符的ASCLL码

添加的长度小于16时,直接添加

添加的长度大于16 ， 则会 扩容: 老容量*2 + 2

如果扩容后的长度还是不够，则以实际长度为准

# 24.为什么重写equals方法时，调用的不是Object方法的equals，而是Objects方法的equals

![为什么要用objects的equals方法](E:\笔记\刷题经验img\为什么要用objects的equals方法.png)

![objet的equals的方法](E:\笔记\刷题经验img\objet的equals的方法.png)

![objects的equals方法](E:\笔记\刷题经验img\objects的equals方法.png)

**objects**的equals方法更加的安全，如果比较的两个值中，有一个为null不会报错，因为他会在内部进行判断

**object**的equals方法就会空指针异常

